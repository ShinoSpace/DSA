## 814. 二叉树剪枝

给定二叉树根结点`root`，此外树的每个结点的值要么是0，要么是1。返回移除了所有不包含1的子树的原二叉树。

注：结点`X`的子树为`X`本身，以及所有`X`的后代。

说明:

+ 给定的二叉树最多有 100 个节点。
+ 每个节点的值只会为 0 或 1 。

原题传送门：[https://leetcode-cn.com/problems/binary-tree-pruning](https://leetcode-cn.com/problems/binary-tree-pruning)

## 参考代码

返回左右子树是否含1结点，若当前结点的子树结点全零，则删当前结点的子结点而不删当前结点。

``` c++
class Solution {
public:
    bool dfs(TreeNode *root){
        // return if subTree has "1" node;
        if(root == nullptr)
            return false;
        bool left_has_one = dfs(root -> left);
        bool right_has_one = dfs(root -> right);
        if(!left_has_one){
            delete root -> left;
            root -> left = nullptr;
        }
        if(!right_has_one){
            delete root -> right;
            root -> right = nullptr;
        }
        return root -> val == 1 || left_has_one || right_has_one;
    }
    TreeNode* pruneTree(TreeNode* root) {
        dfs(root);
        if(root -> val == 0 && !root -> left && !root -> right)
            return nullptr;
        return root;
    }
};
```

更直接：删当前结点，这样就要返回当前结点是否被删除。

``` c++
class Solution {
public:
    bool dfs(TreeNode *root){
        // return if deleted of this level
        if(root == nullptr)
            return true;
        bool left_del = dfs(root -> left);
        bool right_del = dfs(root -> right);
        if(left_del)
            root -> left = nullptr;
        if(right_del)
            root -> right = nullptr;
        if(left_del && right_del && root -> val == 0){
            delete root;
            return true;
        }
        else
            return false;
    }
    TreeNode* pruneTree(TreeNode* root) {
        dfs(root);
        return root;
    }
};
```
