### 写在前面最重要的碎碎念

不夸张地说，「数据结构和算法」就和高考一样，实际应用题目至少有60%是吃经验的，而剩下40%对理论的「融会贯通」则是在获取60%经验的过程中逐渐得到的。因此，能完整用递归方法正确解题不是一蹴而就的。从模仿开始，多做多练多总结，是熟练掌握递归和其他算法的最快也是必经之路。

### 什么情况下可以考虑递归？

这是非常重要的前提：

1. 大问题 = 规模更小的小问题 + 一步处理。
2. 大问题和小问题的解决方法相同。

1，2构成状态转移，是递归最重要也是最吃经验的部分。问题具备这两个性质才可以用递归。

### 递归的三个要素

1. 一步递归操作（状态转移）
2. 返回值（可以是void）
3. 递归终止条件

### 写递归的一些思考

首先必须要说，递归不是目的，而是解决问题的一种方法。随着做题和练习，很容易陷入不分析问题而无脑递归的情况，尤其是「树」相关的题目（几乎所有二叉树相关的题目的第一个想法就是递归）。

正确的做法是：无论碰到什么题目，先分析问题。如果问题满足递归的前提，存在状态转移，那么就可以考虑使用递归解决。

确定问题具备递归解决的条件后，我们必须直面最大的问题：状态转移。这是一个非常吃经验和问题理解的部分，除了多做多练多总结，没有更快的方法（不如说猛刷然后总结是最快的）。在递归三要素中，除了状态转移，还有返回值和递归终止条件。如果没有一个合适的思考框架，我们很容易在三要素中绕进去。幸运的是，我们有一些降低整体递归难度的思考方法。

### 递归三部曲

一般来说，我们可以通过分析具体问题的「语义」来快速确定三要素中的一些要素，例如返回值或递归终止条件。于是一个可行的写递归的方法是：

1. 定义函数功能，给出函数接口，而不管具体实现。这一步根据问题的「语义」宏观地确定函数的输入参数和返回值。根据问题需要，有时可能还需要调整「状态」。
2. 确定大问题和小问题的关系（状态转移）和函数体内其他的操作。这一步思考过程中可能发现需要一些上层递归的信息，迭代更新step.1的函数接口即可。
3. 补充递归终止条件：边界情况和base情况的处理。

总的来说，上面的思考目的是为初入递归的同学缕清思路，提供一种递归地入手方式，并明确递归究竟是难在哪儿。用递归处理问题是一条经验之路，本质上与高考别无二致。找好思考方式和自己习惯的入手角度后，多做多练，自己解不出来时多看高分题解，多总结状态转移方程，是最快将递归方法「内化」的方式。

### 另一条似乎可行的道路

根据递归执行的过程，以递归调用为分界线，可将函数体内的语句分成三部分：

``` c++
ReturnedType f(args){
	some operations;    ←「递」送时执行
	递归调用f();
	some operations;    ←「归」来时执行
	return some_value;
}
```

按照这种划分，我们对于一步递归操作的思考可以更加细致：

1. 递归调用前的部分在「递」送时执行：转移到下一级递归前，本级要做什么？是否有信息需要传给下一层递归？函数参数传递。
2. 递归调用后的部分在「归」来时执行：下一层递归结束后返回本层递归，意味着规模更小的子问题已经解决。也就是说，返回到本级递归时，已经处理好的部分在「后面」。

举两个例子来理解：

+ 例1：二叉树的分治法（后序遍历）
	有些题目是二叉树后续遍历的变形，对于问题理解和分析（经验）要求比较高。之所以特别说后序遍历是分治法，是因为后续遍历确实是严格的先「分」后「治」。

	``` c++
	void postOrderTraversal(TreeNode* root){
		if(root){
			postOrderTraversal(root -> left);		←「分」，递归调用
			postOrderTraversal(root -> right);	   ←「分」，递归调用
			someOperations(root);					  ←「治」，「归」时执行
		}
	}
	```

	这种分治法的特点是：递归调用前没有操作，递归调用后进行操作。也就是说，整个「递」的过程只是分解而不处理问题（分而不治）。「归」来的过程中问题才真正被处理。因此这特别要求我们考虑一步递归操作时，将「后面」视作已经处理完的部分。

+ 例2：反转单链表
	为了更好理解例1和之前的说法，做一题：递归反转单链表。
	反转单链表的递归解法真的是骚到没朋友，开始接触这道题的时候多数人看得懂题解却理解不了思路（为什么会想出这样的方法）。实际上是分治法铺垫在前。按照上面的思路和递归三部曲，一个完整的思考过程可能是这样的：

	1. API和返回值：拿到给定的链表第一个结点head（作为函数参数），返回反转后的链表的第一个结点。
	2. 函数体内的操作：看图（这张图是整个思考过程中最关键的一部分）
	![]

### 问题类型和经验主义

递归作为一种方法，处理的问题非常多变。状态转移的得出非常依赖经验，因此多做题多练习是必要的。就个人经验来说，目前遇到的有几类问题：

1. 有一类问题的递归过程不需要返回值，而是在「递」的过程中动态更新一些全局变量，最终的结果保存在这些全局变量中。大多数这类问题中，「递」占逻辑的绝大部分，「归」可能不进行什么处理操作。相关题目：[662. 二叉树最大宽度][662]。
2. 在本层递归中需要上层递归的结果，因此需要将上层递归的结果作为函数参数进行传递。相关题目：[988. 从叶节点开始的最小字符串][988]，[129. 求根到叶子节点数字之和][129]。

有一些相对较难的问题：

1. 原问题较复杂，需要我们将问题分解为若干相对简单的问题，或是需要将问题转化为另一个与之相关的问题上。解决这些简单或是相关问题的方法是递归。相关题目：[写作easy读作medium的687. 最长同值路径][687]，[确实是hard的124. 二叉树中的最大路径和][124]。
2. 分治法，那种递归非常靠前的分治法。这要求我们对状态转移和返回值要考虑的非常清楚，先「分」（递）后「治」（归）。这类题是极具递归风格的题目，相对来说比较硬，是最吃经验和对题目理解的一类。相关题目：[写作easy读作medium的687. 最长同值路径][687]，[确实是hard的124. 二叉树中的最大路径和][124]。

[662]: ../leetcode/递归（树）/important-and-classical/M-662.二叉树最大宽度.md
[988]: ../leetcode/递归（树）/important-and-classical/M-988.从叶结点开始的最小字符串.md
[129]: ../leetcode/递归（树）/important-and-classical/M-129.求根到叶子节点数字之和.md
[687]: ../leetcode/递归（树）/Divide-and-Conquer/E(M)-687.最长同值路径.md
[124]: ../leetcode/递归（树）/Divide-and-Conquer/H-124.最大路径和.md
