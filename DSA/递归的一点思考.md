### 什么情况下可以考虑递归？

大问题可以分解为规模更小的小问题，大问题和小问题的解决方法是一样的。

### 递归的三个要素

1. 一步递归操作（状态转移）
2. 返回值（可以是void）
3. 递归终止条件

### 写递归的一些思考

从逻辑上讲，递归的三要素在逻辑上似乎构成一个「环」：某层递归可能会用到下一层递归的返回值。一般来说，逻辑上成环的问题解起来确实没那么容易，找到一个入手点是非常关键的。但从过程上看递归，「递」和「归」是两个过程，「递」对应「自顶向下」，「归」对应「自底向上」，并且「先递后归」。因此，写递归的一个直接的入手方式是先考虑「递」后考虑「归」。

一个完整的递归函数，必须显式完成递归的三要素。这三要素中，1是「递」的过程，2和3是「归」的过程。根据前面的思考，我们从「递」入手，考虑一步递归操作。这里一定要注意：

+ 考虑递归的一步操作（状态转移）时，不要考虑返回值和什么时候终止！

「递」的过程中，我们只专注于一步递归需要做什么，「穷举」所有可能的情况即可（分类讨论）。当我们考虑清楚了一步递归以后，再反过来专心于「自底向上」（即「归」的过程）。这时候，终止条件和返回值可以结合一步操作的逻辑得出，并且可以反过来验证一步递归操作的逻辑是否正确。也就是说，我们在「归」的时候完成整个递归函数的综合考量。

总结一下：

+ 从「递」的过程入手，专心考虑一步操作（状态转移），只考虑这个问题的主干是怎么解的，即考虑主体。
+ 主体写出来后，切换到「归」的模式，在「自底向上」的过程中考虑返回值和递归终止条件，并综合验证递归函数逻辑的正确性。

这样可以把自己思绪理清楚，避免「东一榔头，西一棒子」式的杂乱无章的思考。

要说明的是，以上思考并非一成不变的。例如某些问题可以根据题目「语义」迅速确定递归的返回值，那么在思考一步递归操作时，完全可以将返回值作为「已知条件」来使用。还有的时候，一步递归操作的处理中可能要用到返回值，这时候也可能需要根据「语义」先确定返回值。总的来说，上面的思考为初入递归而无所适从的同学提供一种相对清晰且直接的思考方式。随着更多的练习，需要将以上思考方式快速灵活地进行调整，以适应不同的问题。

### 问题类型和经验主义

递归作为一种方法，处理的问题非常多变。状态转移的得出非常依赖经验，因此多做题多练习是必要的。就个人经验来说，目前遇到的有几类问题：

1. 有一类问题的递归过程不需要返回值，而是在「递」的过程中动态更新一些全局变量，最终的结果保存在这些全局变量中。大多数这类问题中，「递」占逻辑的绝大部分，「归」可能不进行什么处理操作。相关题目：[662. 二叉树最大宽度][662]
2. 在本层递归中需要上层递归的结果，因此需要将上层递归的结果作为函数参数进行传递。相关题目：[988. 从叶节点开始的最小字符串][988]，[129. 求根到叶子节点数字之和][129]

用递归处理问题是一条经验之路，本质上与高考别无二致。找好思考方式和自己习惯的入手角度后，多做多练，自己解不出来时多看高分题解，多总结，是最快将递归方法「内化」的方式。

### 写递归的一个方法

1. 定义函数功能，而不管具体实现。这一步根据问题的「语义」宏观地确定函数的输入参数和返回值（吃经验，尤其是递归需要额外参数的情况）。
2. 确定大问题和小问题的关系。这一步是在找状态转移。（最吃经验的一步，包括对问题的分析）
3. 补上递归终止条件：边界情况和base情况的处理。（这里确实分析为主，但这个分析多数就是分类讨论，并不难。主要还是依赖于step2中对问题的分解。）

[662]: ../leetcode/递归（树）/important%20&%20classical/M-662.二叉树最大宽度.md
[988]: ../leetcode/递归（树）/important%20&%20classical/M-988.从叶结点开始的最小字符串.md
[129]: ../leetcode/递归（树）/important%20&%20classical/M-129.求根到叶子节点数字之和.md
