## 哈希查找的概念和目的

数组可以根据索引（下标）以O(1)的时间复杂度对元素进行随机存取。哈希查找希望根据给定的`关键词(key)`，在平均O(1)的时间下访问关键词对应的`值(value)`。

为了在计算机中实现哈希查找，我们需要借助数组以达到O(1)的时间复杂度。因此就需要将key映射到数组索引（下标）。这种映射关系称为`哈希函数`。哈希函数是key到数组索引的映射。

考虑存储空间的效率问题，我们希望key到索引的映射关系是"一一对应"的（单射且满射），即每个key都映射到唯一的索引。但这种哈希函数是很难找到的：

+ 实际情况中的key是各式各样的：数字，字符串，甚至对象都有可能。
+ 由于key的多样性，哈希函数可能将不同的key映射到同一个索引。因此哈希函数必然要面对并解决映射`冲突`问题。

例如`除留取余法`构建的的哈希函数：
$$
h(key) = key \hspace{2mm} mod \hspace{2mm} 17 \tag{1}
$$
对于key=2和key=19，他们均映射到同样的索引2。存储这两个key对应的value时就要解决"冲突"问题。解决冲突问题的方法有很多，例如开放寻址法、拉链法、二次散列法等。

假设我们用`线性探测法`解决冲突了问题。`线性探测法`是说：对于冲突的key，我们循环试探冲突位置的下一个位置，直到不冲突为止。例如(1)式的哈希函数，对于key的集合{2, 18, 36, 19, 55}，其哈希值为：

| key | 2 | 18 | 39 | 19 | 55 |
| :-: | :-: | :-: | :-: | :-: | :-: |
| 冲突处理前h(key) | 2 | 1 | 5 | 2 | 4 |
| 冲突处理后index = h(key) | 2 | 1 | 5 | <font color='red'> 3 </font> | 4 |

注意，我们是先对key=2求哈希值，并将其对应的value存储在数组索引为2的空间。而后到来的key=19求哈希也为2，发生冲突，于是根据线性探测法，在index = 3的位置探测到空闲空间并存储对应的value。

接下来问题来了：后续使用key=19查找时，存储时是否发生冲突对于后续查找来说是透明的。也就是说在查找时我们并不知道存储过程中是否发生了冲突。这个问题原因在于信息不对称：如果事先存储时没有记录key，查询时将不能确定存储时是否存在冲突。因此在存储时保存key信息，问题就解决了。

综上所述，我们在存储时建立一张表（由于哈希值是数组索引，因此这张表实际上就是一个数组），需要记录三个关键信息：

1. 关键词key
2. key对应的哈希值h(key)
3. key对应的value

这张表称为`哈希表(Hash Table)`。具体来说：  
存储时，哈希函数为每个key计算一个哈希值h(key)，这个值就是`键值对(key-value pair)`在数组中的存储位置。如果发生了冲突，即key1≠key2，但h(key1)=h(key2)，则按照冲突解决方法再探测。  
查询时，对查询关键词query，首先计算哈希值h(query)。然后在数组上定位到索引为h(query)的位置，检查该位置元素的key是否与query匹配：若匹配，则查找成功，返回对应的value；若不匹配，说明存储时可能发生了冲突，则按照冲突解决方法循环进行探测，直到key匹配（查找成功）或遇到空闲空间（哈希表中不存在key，查找失败）为止。

哈希查找过程示例：
![哈希查找过程](./哈希查找/hashTable.png)

## 总结：哈希查找的过程

将上面的问题和解决方法做个总结，俯瞰整个哈希查找的过程：

+ 哈希表和哈希存储的建立过程：  
step1. 确定合适的哈希函数。  
step2. 对给定的key，使用哈希函数+冲突处理方法得到`哈希值h(key)`。所有键值对(key, value)存储在数组中索引为h(key)的位置，建立`哈希表`。再次强调，哈希函数+冲突解决方法得到的`哈希值`就是数组`索引`。

+ 哈希查找的过程：  
step1. 根据哈希函数计算query对应的哈希值h(query)。  
step2. 定位到哈希表索引为h(query)的位置，检查键值对的key是否匹配query。若匹配，则查找成功，返回键值对的value值。否则，说明存储过程中可能发生了冲突，按照冲突处理规则进行循环探测，直到key匹配（查找成功）或遇到空闲空间（哈希表中不存在key，查找失败）为止。
